# -*- coding: utf-8 -*-"""Created on Wed Apr 10 16:10:57 2019@author: 蔡佳超"""import numpy as npimport randomclass AntList(object):    def __init__(self,distfunc,getEtatable,numant=5,numcity=10,alpha=1,beta=2,rho=0.5,Q=100,aCrossRate=0.9, aMutationRage=0.9):        """ 构造函数 """        self.numant = numant        # 蚂蚁个数        self.numcity = numcity        # 城市个数        self.alpha = alpha            # 信息启发式因子[0,5]        self.beta = beta              # 期望启发式因子[0,5]        self.rho = rho                # 信息素的挥发速度[0.1,0.99]        self.Q = Q                    # 品质因子[10-10000]        self.distfunc=distfunc        self.getEtatable=getEtatable        self.q0=0.9        self.crossRate = aCrossRate          # 交叉概率 #        self.mutationRate = aMutationRage      # 突变概率 #        self.bestantunit=None        self.population=[]        self.pathtable = np.zeros((self.numant,self.numcity)).astype(int)    # 路径记录表        self.generation=0    def Init_eta_phe(self):        self.etatable = self.getEtatable()            # 启发函数矩阵，表示蚂蚁从城市i转移到矩阵j的期望程度        self.pheromonetable  = np.ones((self.numcity,self.numcity))            # 信息素矩阵    def InitStartPosition(self):        #  随机产生各个蚂蚁的起点城市        if self.numant <= self.numcity:       # 城市数比蚂蚁数多            self.pathtable[:,0] = np.random.permutation(range(0,self.numcity))[:self.numant]        else:                               # 蚂蚁数比城市数多，需要补足            self.pathtable[:self.numcity,0] = np.random.permutation(range(0,self.numcity))[:]            self.pathtable[self.numcity:,0] = np.random.permutation(range(0,self.numcity))[:self.numant-self.numcity]    def upDateInf(self):        changepheromonetable = np.zeros((self.numcity,self.numcity))                  if self.population:            best=self.bestantunit            for i in range(self.numcity-1):                changepheromonetable[best.path[i]][best.path[i+1]] += self.Q/best.length                changepheromonetable[best.path[i+1]][best.path[i]] += self.Q/best.length            changepheromonetable[best.path[self.numcity-1]][best.path[0]] += self.Q/best.length            changepheromonetable[best.path[best.path[0]]][self.numcity-1] += self.Q/best.length            self.pheromonetable = (1-self.rho)*self.pheromonetable + self.rho*changepheromonetable        else:            self.Init_eta_phe()    def getNextCity(self,unvisited,visiting):        listunvisited = list(unvisited)        probtrans = np.zeros(len(listunvisited))        q=np.random.rand()                        for k in range(len(listunvisited)):            probtrans[k] = np.power(self.pheromonetable[visiting][listunvisited[k]],self.alpha)\                *np.power(self.etatable[visiting][listunvisited[k]],self.beta)        if q>self.q0:            cumsumprobtrans = (probtrans/sum(probtrans)).cumsum()            cumsumprobtrans -= np.random.rand()            k = listunvisited[np.where(cumsumprobtrans>0)[0][0]] # 下一个要访问的城市        else:            m = np.argmax(probtrans)            k = listunvisited[m]        return k    def GoOnePath(self,i):        visiting = self.pathtable[i,0]        # 当前所在的城市        unvisited = set(range(self.numcity))# 未访问的城市        unvisited.remove(visiting)            # 删除元素                for j in range(1,self.numcity):        # 循环numcity-1次，访问剩余的numcity-1个城市            # 每次用轮盘法选择下一个要访问的城市            k=self.getNextCity(unvisited,visiting)                        self.pathtable[i,j] = k            unvisited.remove(k)            visiting = k                antunit=AntUnit(self.pathtable[i],self.distfunc(self.pathtable[i]))        #局部更新        for i in range(self.numcity-1):            level=self.pheromonetable[antunit.path[i]][antunit.path[i+1]]            self.pheromonetable[antunit.path[i]][antunit.path[i+1]] = (1-self.rho)*level+self.rho*self.Q/antunit.length            self.pheromonetable[antunit.path[i+1]][antunit.path[i]] = (1-self.rho)*level+self.rho*self.Q/antunit.length        levelb=self.pheromonetable[antunit.path[self.numcity-1]][antunit.path[0]]        self.pheromonetable[antunit.path[self.numcity-1]][antunit.path[0]] = (1-self.rho)*levelb+self.rho*self.Q/antunit.length        self.pheromonetable[antunit.path[0]][antunit.path[self.numcity-1]] = (1-self.rho)*levelb+self.rho*self.Q/antunit.length        if self.bestantunit:            if self.bestantunit.length>antunit.length:                self.bestantunit=antunit        else:            self.bestantunit=antunit                return antunit        def nextGeneration(self,qn=0.5):        self.upDateInf()        newPopulation = []                        # 新种群        for i in range(self.numant):            self.q0=qn            newPopulation.append(self.GoOnePath(i))        self.population = newPopulation        self.generation += 1        def upDateInf_mix(self):        changepheromonetable = np.zeros((self.numcity,self.numcity))                  if self.population:            for antunit in self.population:                for i in range(self.numcity-1):                    changepheromonetable[antunit.path[i]][antunit.path[i+1]] += self.Q/antunit.length                    changepheromonetable[antunit.path[i+1]][antunit.path[i]] += self.Q/antunit.length                changepheromonetable[antunit.path[self.numcity-1]][antunit.path[0]] += self.Q/antunit.length                changepheromonetable[antunit.path[0]][antunit.path[self.numcity-1]] += self.Q/antunit.length        else:            self.Init_eta_phe()        def cross(self, parent1, parent2):        index1 = random.randint(0, self.numcity - 1)          # 随机生成突变起始位置 #        index2 = random.randint(index1, self.numcity - 1)      # 随机生成突变终止位置 #        tempGene = parent2.path[index1:index2]                  # 交叉的基因片段        newGene = []        p1len = 0        for g in parent1.path:            if p1len == index1:                newGene.extend(tempGene)          # 插入基因片段                p1len += 1            if g not in tempGene:                newGene.append(g)                p1len += 1        newchild=AntUnit(newGene,self.distfunc(newGene))        return newchild        def mutation(self, antunit):        index1 = random.randint(0, self.numcity - 1)        index2 = random.randint(0, self.numcity - 1)        # 随机选择两个位置的基因交换--变异        gene=antunit.path        newGene = gene[:]                      # 产生一个新的基因序列，以免变异的时候影响父种群        newGene[index1], newGene[index2] = newGene[index2], newGene[index1]        newant=AntUnit(newGene,self.distfunc(newGene))        return newant        def GoOnePath_mix(self,i):        visiting = self.pathtable[i,0]        # 当前所在的城市        unvisited = set(range(self.numcity))# 未访问的城市        unvisited.remove(visiting)            # 删除元素                for j in range(1,self.numcity):        # 循环numcity-1次，访问剩余的numcity-1个城市            # 每次用轮盘法选择下一个要访问的城市            k=self.getNextCity(unvisited,visiting)                        self.pathtable[i,j] = k            unvisited.remove(k)            visiting = k                antunit=AntUnit(self.pathtable[i],self.distfunc(self.pathtable[i]))        if self.bestantunit:            if self.bestantunit.length>antunit.length:                self.bestantunit=antunit        else:            self.bestantunit=antunit                return antunit        def nextGeneration_mix(self,qn=0.5):        self.upDateInf_mix()        newPopulation = []                        # 新种群        for i in range(self.numant):            self.q0=qn            newPopulation.append(self.GoOnePath_mix(i))        newPopulation.sort(key=lambda AntUnit:AntUnit.length,reverse=False)        crossparent=newPopulation[0]        for i in range(1,self.numant):            rate = random.random()            # 按概率交叉            if rate < self.crossRate:    # 交叉                 newchild=self.cross(crossparent,newPopulation[i])                if newchild.length<newPopulation[i].length:                    newPopulation[i]=newchild        # 按概率突变        for i in range(self.numant):            rate = random.random()            if rate < self.mutationRate:                newant = self.mutation(newPopulation[i])                if newant.length<newPopulation[i].length:                    newPopulation[i]=newant        newPopulation.sort(key=lambda AntUnit:AntUnit.length,reverse=False)        if self.bestantunit.length>newPopulation[0].length:                self.bestantunit=newPopulation[0]        self.population = newPopulation        self.generation += 1        class AntUnit(object):    """        类名：AntUnit        类说明：    蚁群算法个体类    """    def __init__(self, aPath = None,aLength = -1):        """ 构造函数 """        self.path = list(aPath)            # 个体的基因序列        self.length = aLength              # 初始化适配值